# ERD Editor

## 프로젝트 개요

데이터베이스 설계 과정에서 기존 도구들의 한계를 느끼게 되었습니다. MySQL Workbench나 ERDCloud 같은 도구들은 설치가 필요하거나 웹에서도 복잡한 인터페이스를 가지고 있어서, 간단하고 직관적인 웹 기반 ERD 편집기를 만들어보고 싶었습니다. 특히 React Flow의 강력한 다이어그램 편집 기능을 활용하면 드래그 앤 드롭으로 쉽게 엔티티를 배치하고 관계를 정의할 수 있을 것 같았습니다. 

이 프로젝트는 React와 TypeScript를 기반으로 구축했으며, React Flow를 핵심 라이브러리로 사용하여 웹 브라우저에서 바로 사용할 수 있는 완전한 ERD 편집기를 만들었습니다. 사용자는 별도 설치 없이 웹 브라우저만으로 데이터베이스 스키마를 시각적으로 설계하고 문서화할 수 있게 되었습니다.

## 🔗Link

### Github
https://github.com/kimbongjune/erd-editor

### Home Page
http://localhost:5173 (개발 환경)

## 기술 스택

### Frontend
- **React 19.1.0** - 사용자 인터페이스 구축
- **TypeScript 5.8.3** - 타입 안전성과 개발 생산성 향상
- **React Flow 11.11.4** - 다이어그램 편집 및 노드/엣지 관리
- **Styled Components 6.1.19** - CSS-in-JS 스타일링
- **React Router DOM 7.7.1** - 클라이언트 사이드 라우팅

### State Management & Utilities
- **Zustand 5.0.6** - 경량 상태 관리 라이브러리
- **React Toastify 11.0.5** - 사용자 알림 시스템
- **React Dropzone 14.3.8** - 파일 업로드 기능
- **React Color 2.19.3** - 색상 선택기 컴포넌트
- **React Icons 5.5.0** - 아이콘 라이브러리

### Development Tools
- **Vite 7.0.5** - 빠른 개발 서버 및 빌드 도구
- **HTML-to-Image 1.11.13** - 다이어그램 이미지 내보내기
- **Lodash Throttle 4.1.1** - 성능 최적화를 위한 함수 스로틀링

## 핵심 기능 구현

### React Flow 기반 다이어그램 편집 시스템

웹에서 다이어그램을 편집하려면 드래그 앤 드롭 기능이 필수였습니다. 처음에는 Canvas API나 SVG를 직접 조작하는 방법을 고려했지만, 복잡한 이벤트 처리와 상태 관리가 필요할 것 같았습니다. 그래서 React Flow를 선택했는데, 이 라이브러리는 노드와 엣지의 생명주기를 완전히 관리해주고, 줌/팬, 선택, 드래그 등의 기본 기능을 모두 제공합니다.

React Flow의 가장 큰 장점은 커스텀 노드와 엣지를 쉽게 만들 수 있다는 점이었습니다. ERD에 특화된 엔티티 노드를 만들어서 테이블 형태로 컬럼 정보를 표시하고, 관계선은 Identifying/Non-identifying을 구분해서 다른 스타일로 표현했습니다. 또한 핸들 위치를 자동으로 계산해서 엔티티의 테이블 구조에 맞게 배치하도록 구현했습니다.

처음에는 React Flow의 기본 노드만 사용했는데, ERD의 복잡한 구조를 표현하기에는 부족했습니다. 그래서 완전히 커스텀한 엔티티 노드를 만들어서 컬럼 추가/삭제, 데이터 타입 변경, 제약조건 설정 등을 모두 노드 내부에서 처리할 수 있게 했습니다. 이렇게 하니 사용자가 직관적으로 테이블 구조를 편집할 수 있게 되었습니다.

### 다양한 노드 타입 지원

ERD 다이어그램에는 엔티티뿐만 아니라 설명이나 메모가 필요할 때가 많습니다. 그래서 Comment 노드와 Text 노드를 추가로 구현했습니다. Comment 노드는 다이어그램에 설명을 추가할 수 있게 해주고, Text 노드는 간단한 텍스트 요소를 제공합니다.

특히 Image 노드는 개발하면서 가장 어려웠던 부분 중 하나였습니다. 처음에는 단순히 이미지 URL을 입력받아서 표시하는 방식으로 구현했는데, 사용자들이 로컬 파일을 업로드하고 싶어한다는 피드백을 받았습니다. 그래서 FileReader API를 사용해서 로컬 파일을 Base64로 변환하는 기능을 추가했습니다.

이미지 업로드에서 가장 큰 문제는 파일 크기 제한이었습니다. 처음에는 제한을 두지 않았는데, 큰 이미지 파일을 업로드하면 브라우저가 느려지는 문제가 발생했습니다. 그래서 5MB 제한을 두고, 파일 타입도 이미지만 허용하도록 검증 로직을 추가했습니다.

### 관계선 타입 및 식별자 관리

ERD에서 가장 중요한 것은 관계 표현입니다. 처음에는 단순한 선으로만 관계를 표현했는데, Identifying과 Non-identifying 관계를 구분해야 한다는 요구사항이 있었습니다. Identifying 관계는 실선으로, Non-identifying은 점선으로 표현하도록 구현했습니다.

관계선 연결에서 가장 어려웠던 부분은 핸들 위치 계산이었습니다. 엔티티 노드의 크기가 동적으로 변할 수 있어서, 핸들 위치를 정확히 계산하는 것이 복잡했습니다. 처음에는 고정된 위치에 핸들을 배치했는데, 엔티티 크기가 변하면 핸들이 엔티티 밖으로 나가는 문제가 발생했습니다. 그래서 엔티티의 실제 테두리 위치를 계산해서 핸들을 동적으로 배치하도록 수정했습니다.

복합키 관리 기능을 구현할 때 가장 까다로웠던 부분은 순환 참조 문제였습니다. 여러 컬럼으로 구성된 기본키나 외래키를 지원해야 했는데, 관계가 변경될 때마다 관련된 엔티티들의 키 정보를 자동으로 업데이트해야 했습니다.

문제는 컬럼이 삭제될 때 해당 컬럼을 참조하는 관계들도 함께 업데이트해야 하는데, 이 과정에서 순환 참조가 발생할 수 있다는 것이었습니다. 예를 들어 A가 B를 참조하고, B가 C를 참조하는데, C가 다시 A를 참조하는 경우가 있었습니다.

이 문제를 해결하기 위해 관계 그래프를 먼저 분석해서 순환 구조를 감지하고, 삭제 순서를 정해서 안전하게 처리하도록 구현했습니다. 또한 각 관계에 고유한 ID를 부여해서 어떤 관계가 어떤 관계를 참조하는지 명확하게 추적할 수 있게 했습니다.

결과적으로 복합키가 있는 복잡한 관계도 안전하게 관리할 수 있게 되었고, 순환 참조로 인한 오류가 발생하지 않게 되었습니다.

### 이미지 노드 고급 기능

다이어그램에 시각적 요소를 추가할 수 있도록 이미지 노드 기능을 구현했습니다. 처음에는 간단한 아이콘 정도만 생각했는데, 사용자들이 로고나 설명 이미지를 넣고 싶어해서 더 고급 기능들을 추가하게 되었습니다.

가장 큰 문제는 이미지 업로드와 URL 입력 두 가지 방식을 모두 지원해야 한다는 것이었습니다. 파일 업로드는 Base64로 변환해서 저장해야 하고, URL은 실제로 유효한 이미지인지 검증해야 했습니다.

이 문제를 해결하기 위해 두 가지 접근 방식을 구현했습니다. 첫 번째는 파일 드롭존을 만들어서 사용자가 이미지를 드래그앤드롭으로 업로드할 수 있게 했고, 두 번째는 Image 객체를 사용해서 URL의 유효성을 검증하는 시스템을 만들었습니다. URL 검증에는 5초 타임아웃을 설정해서 무한 로딩을 방지했습니다.

결과적으로 사용자가 로컬 파일과 웹 이미지를 모두 자유롭게 사용할 수 있게 되었고, 잘못된 이미지가 들어와도 안전하게 처리할 수 있게 되었습니다.

### 테마 시스템 및 다크모드 지원

사용자 경험을 향상시키기 위해 테마 시스템을 구현했습니다. 처음에는 라이트모드만 지원했는데, 사용자들이 다크모드를 요청해서 추가하게 되었습니다.

다크모드 구현에서 가장 까다로웠던 부분은 색상 대비였습니다. 단순히 색상을 반전시키는 것이 아니라, 가독성을 고려해서 적절한 색상 조합을 찾아야 했습니다. 특히 관계선과 노드 테두리, 텍스트 색상 등을 다크모드에서도 명확하게 구분할 수 있도록 조정했습니다.

테마 전환 시 깜빡임 현상도 문제였는데, 처음에는 테마가 변경될 때마다 모든 컴포넌트가 리렌더링되면서 깜빡이는 현상이 발생했습니다. 그래서 CSS 변수를 사용해서 테마 색상을 관리하고, transition 효과를 추가해서 부드러운 전환을 구현했더니 문제가 해결되었습니다.

### 데이터 저장 및 관리

사용자가 작업한 내용을 안전하게 보관할 수 있도록 저장 기능을 구현했습니다. 처음에는 브라우저를 새로고침하면 모든 작업이 사라져서 사용자들이 불편해했습니다.

문제는 웹 애플리케이션의 특성상 페이지를 새로고침하거나 브라우저를 닫으면 메모리에 있던 모든 데이터가 사라진다는 것이었습니다. 사용자들이 실수로 데이터를 잃어버리는 경우가 많았습니다.

이 문제를 해결하기 위해 localStorage를 활용한 저장 시스템을 구현했습니다. 사용자가 저장 버튼을 클릭하면 현재 작업 상태가 브라우저 로컬 저장소에 저장되고, 페이지를 다시 열면 이전 작업을 불러올 수 있게 했습니다.

결과적으로 사용자가 안심하고 작업할 수 있게 되었고, 실수로 페이지를 새로고침해도 저장된 내용을 복구할 수 있게 되었습니다.

### 히스토리 관리 및 Undo/Redo

사용자가 작업을 안전하게 되돌릴 수 있도록 히스토리 관리 시스템을 구현했습니다. 처음에는 단순히 이전 상태를 저장하는 방식으로 구현했는데, 메모리 사용량이 너무 많아지는 문제가 발생했습니다.

히스토리 관리를 개선하기 위해 액션 기반 시스템으로 변경했습니다. 각 작업을 액션으로 정의하고, 액션을 실행/취소하는 방식으로 구현했는데, 이렇게 하니 메모리 사용량을 크게 줄일 수 있었고, 복잡한 작업도 정확하게 되돌릴 수 있게 되었습니다.

Undo/Redo 단축키 구현에서 가장 까다로웠던 부분은 브라우저의 기본 동작과 충돌하는 것이었습니다. Ctrl+Z는 브라우저에서 기본적으로 뒤로가기로 동작하기 때문에, preventDefault를 사용해서 기본 동작을 막아야 했습니다. 또한 여러 컴포넌트에서 단축키를 처리할 때 이벤트 버블링 문제도 있었는데, 이런 문제들을 모두 해결해서 안정적인 단축키 시스템을 만들 수 있었습니다.

### 검색 및 필터링 기능

대규모 다이어그램에서 특정 요소를 빠르게 찾을 수 있도록 검색 기능을 구현했습니다. 처음에는 단순히 노드 이름만 검색했는데, 사용자들이 컬럼명이나 데이터 타입으로도 검색하고 싶어한다는 요청을 받았습니다.

검색 기능 구현에서 가장 까다로웠던 부분은 실시간 검색 결과 하이라이트였습니다. 검색어가 변경될 때마다 관련 노드들을 시각적으로 강조해야 하는데, React Flow의 노드 스타일을 동적으로 변경하는 것이 복잡했습니다. 

그래서 검색 결과를 상태로 관리하고, 노드 렌더링 시 검색 결과에 따라 스타일을 적용하도록 구현했더니 문제가 해결되었습니다. 이제 사용자가 검색어를 입력하면 관련 노드들이 바로 하이라이트되어 쉽게 찾을 수 있게 되었습니다.

숨겨진 엔티티 관리 기능도 추가했습니다. 복잡한 다이어그램에서 특정 엔티티를 임시로 숨기고 싶어하는 사용자들이 많았습니다. 이 기능을 구현할 때는 React Flow의 노드 필터링 기능을 활용했습니다.

### 정렬 및 레이아웃 관리

다이어그램의 가독성을 향상시키기 위한 정렬 기능을 구현했습니다. 처음에는 단순히 선택된 노드들을 정렬하는 기능만 있었는데, 사용자들이 더 다양한 정렬 옵션을 요청했습니다.

정렬 기능 구현에서 가장 까다로웠던 부분은 기준점 설정이었습니다. 사용자가 어떤 기준으로 정렬할지 선택할 수 있도록 했는데, 기준점에 따라 정렬 결과가 달라져서 혼란을 주는 경우가 있었습니다. 

그래서 정렬 전에 미리보기 기능을 추가해서 사용자가 결과를 확인할 수 있도록 구현했더니 문제가 해결되었습니다. 이제 사용자가 정렬 기준을 바꿔가면서 결과를 미리 확인할 수 있어서 더 안전하게 정렬할 수 있게 되었습니다.

스냅 가이드 기능도 구현했습니다. 노드들이 정확한 위치에 배치되도록 도와주는 기능인데, 그리드 시스템을 활용해서 구현했습니다. 처음에는 고정된 그리드만 지원했는데, 사용자가 그리드 크기를 조정할 수 있도록 개선했습니다.

### 색상 관리 및 시각적 커스터마이징

다이어그램의 시각적 구분을 위해 노드별 색상 관리 시스템을 구현했습니다. 처음에는 모든 노드가 같은 색상이었는데, 사용자들이 각 엔티티를 구분하기 쉽게 색상을 다르게 설정하고 싶어했습니다.

색상 선택기를 구현할 때는 react-color 라이브러리를 사용했습니다. 이 라이브러리는 다양한 색상 선택기를 제공해서 사용자가 쉽게 색상을 선택할 수 있습니다. 처음에는 단순한 색상 팔레트만 제공했는데, 사용자들이 더 다양한 색상 옵션을 요청해서 HSL 색상 선택기도 추가했습니다.

색상 정보를 로컬 스토리지에 저장할 때는 Map 객체를 직렬화하는 문제가 있었습니다. Map은 JSON.stringify로 직렬화할 수 없어서 Array로 변환해서 저장하고, 로드할 때 다시 Map으로 변환하는 로직을 구현했더니 문제가 해결되었습니다.

### 뷰 설정 및 표시 옵션

데이터베이스 설계의 다양한 단계에 맞춰 뷰 설정 기능을 구현했습니다. 논리적 설계 단계와 물리적 설계 단계에서 필요한 정보가 다르기 때문에 뷰를 전환할 수 있는 기능이 필요했습니다.

뷰 설정 구현에서 가장 까다로웠던 부분은 상태 관리였습니다. 각 뷰 설정이 다이어그램별로 독립적으로 저장되어야 하는데, 전역 상태와 로컬 상태를 적절히 분리해야 했습니다. 

그래서 뷰 설정은 다이어그램별로 저장하고, 전역 설정은 별도로 관리하도록 구현했더니 문제가 해결되었습니다. 이제 각 다이어그램마다 독립적인 뷰 설정을 가질 수 있게 되었습니다.

표시 옵션도 세밀하게 제어할 수 있도록 구현했습니다. 기본키/외래키 표시, 데이터 타입 표시, 제약조건 표시, 기본값 표시 등을 개별적으로 설정할 수 있어서 사용자의 필요에 맞춰 다이어그램을 커스터마이징할 수 있습니다.

### 데스크톱 중심 설계 및 접근성

이 프로젝트는 데스크톱 환경에서 사용하는 것을 목표로 개발했습니다. ERD 편집이라는 작업 특성상 큰 화면과 정밀한 마우스 조작이 필요하다고 판단했기 때문입니다.

처음에는 모바일이나 태블릿 지원도 고려해봤는데, 복잡한 다이어그램을 작은 화면에서 편집하기에는 UX적으로 한계가 있다고 생각했습니다. 특히 여러 노드를 동시에 선택하거나 세밀한 관계선 연결 작업은 터치 인터페이스로는 어려울 것 같았습니다.

그래서 데스크톱에 최적화된 인터페이스로 집중해서 개발했습니다. 마우스 오른쪽 클릭 컨텍스트 메뉴, 드래그 앤 드롭, 키보드 단축키 등 데스크톱 환경에서 익숙한 조작 방식들을 적극 활용했습니다.

접근성 측면에서는 키보드만으로도 모든 기능을 사용할 수 있도록 구현했습니다. Tab 키로 요소들을 순회할 수 있고, Enter나 Space로 버튼을 누를 수 있으며, Ctrl+Z/Y 같은 표준 단축키들도 지원합니다.

### 성능 최적화 및 메모리 관리

대규모 다이어그램에서도 부드러운 성능을 보장하기 위해 다양한 최적화 기법을 적용했습니다. 처음에는 성능 최적화를 고려하지 않고 개발했는데, 노드가 많아지면 렌더링 성능이 떨어지는 문제가 발생했습니다.

성능 최적화에서 가장 효과적이었던 것은 React.memo를 활용한 컴포넌트 최적화였습니다. 노드 컴포넌트들이 불필요하게 리렌더링되는 것을 방지해서 성능을 크게 향상시킬 수 있었습니다.

히스토리 관리에서도 메모리 효율성을 고려했습니다. 히스토리는 최대 50개까지 저장하고, 새로운 작업을 수행하면 이후의 히스토리는 자동으로 제거하도록 구현했는데, 이렇게 하니 메모리 사용량을 크게 줄일 수 있었고, 안정적인 성능을 보장할 수 있게 되었습니다.

### 에러 처리 및 사용자 피드백

개발 초기에는 뭔가 잘못되면 그냥 콘솔에만 에러가 찍히고 사용자는 뭐가 문제인지 전혀 모르는 상황이 많았습니다. 특히 이미지 URL이 잘못되거나 파일 업로드가 실패했을 때 사용자가 계속 기다리고 있는데 아무 반응이 없어서 답답해하는 경우가 있었습니다.

이런 문제들을 해결하려고 Toast 알림 시스템을 도입했습니다. 작업이 성공했을 때는 "저장되었습니다" 같은 메시지를, 실패했을 때는 "이미지를 불러올 수 없습니다" 같은 구체적인 에러 메시지를 보여주도록 했습니다. 그리고 노드나 관계를 삭제할 때는 "정말 삭제하시겠습니까?" 같은 확인 창을 띄워서 실수로 지우는 것을 방지했습니다.

입력값 검증도 실시간으로 하도록 바꿨습니다. 예를 들어 컬럼명에 특수문자를 입력하면 바로 빨간색으로 표시되고 "영문자, 숫자, 언더스코어만 사용 가능합니다" 같은 메시지가 나오도록 했습니다. 이렇게 하니까 사용자들이 훨씬 편하게 사용할 수 있게 되었습니다.

### 바이브 코딩 경험

UI 개발에서 새로운 접근 방식을 시도해봤습니다. 평소에는 피그마로 디자인하고 그걸 보면서 HTML/CSS를 직접 코딩하는 방식이었는데, 이번에는 바이브 코딩을 사용해서 디자인부터 퍼블리싱까지 한 번에 처리해봤습니다.

바이브 코딩에 "모던한 ERD 에디터의 버튼 컴포넌트"나 "다크 테마 지원하는 툴바" 같은 프롬프트를 주면 디자인과 함께 실제 사용할 수 있는 HTML/CSS 코드까지 생성해줘서 놀랐습니다. 생성된 코드를 그대로 복사해서 Styled Components로 변환하니까 바로 프로젝트에 적용할 수 있었습니다.

특히 컬러 팔레트나 버튼 호버 효과, 애니메이션 같은 디테일한 부분들도 코드로 바로 나와서 개발 시간이 크게 단축되었습니다. 물론 프로젝트에 맞게 세부 조정은 해야 했지만, 기본 구조와 스타일링이 이미 완성되어 있으니까 훨씬 효율적이었습니다.

앞으로는 UI 컴포넌트 개발할 때 바이브 코딩을 적극 활용해볼 생각입니다. 디자인과 코딩을 동시에 처리할 수 있어서 프로토타이핑 속도가 확실히 빨라지는 걸 체감했습니다. 
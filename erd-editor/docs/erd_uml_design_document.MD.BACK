## 웹/데스크톱 ERD & UML 다이어그램 에디터 상세 설계 문서

### 1. 개요

#### 1.1. 프로젝트 목표 및 비전
본 프로젝트는 웹 브라우저 환경과 독립적인 설치형 데스크톱 애플리케이션(Electron 기반) 환경 모두에서 원활하게 동작하는 통합 ERD(Entity-Relationship Diagram) 및 UML(Unified Modeling Language) 다이어그램 생성 및 편집 도구를 개발하는 것을 목표로 한다. 기존의 복잡하거나 특정 플랫폼에 종속적인 다이어그램 도구들의 한계를 극복하고, 사용자에게 직관적이고 효율적인 시각적 모델링 경험을 제공하여 소프트웨어 및 데이터베이스 설계 프로세스를 혁신하고자 한다.

**비전:**
*   **접근성:** 언제 어디서든 웹 브라우저를 통해 접근 가능하며, 오프라인 환경에서도 데스크톱 앱으로 작업 연속성을 보장한다.
*   **생산성:** 드래그 앤 드롭, 자동 정렬, 단축키 등 직관적인 UI/UX를 통해 설계 시간을 단축하고 생산성을 극대화한다.
*   **정확성:** ERD의 DDL(Data Definition Language) 생성 및 UML의 코드 스켈레톤 생성 등, 다이어그램과 실제 코드 간의 동기화를 지원하여 설계 오류를 줄인다.
*   **확장성:** 플러그인 아키텍처를 고려하여 향후 다양한 다이어그램 유형(BPMN, Flowchart 등) 및 외부 시스템 연동(Git, CI/CD)을 용이하게 한다.

#### 1.2. 대상 사용자 및 활용 시나리오
*   **소프트웨어 개발자 (프론트엔드/백엔드):**
    *   **시나리오:** 새로운 기능 개발 전 데이터베이스 스키마를 ERD로 설계하거나, 기존 시스템의 클래스 구조를 UML 클래스 다이어그램으로 분석한다. 설계 내용을 팀원들과 공유하고 피드백을 반영하여 빠르게 수정한다.
*   **시스템 아키텍트:**
    *   **시나리오:** 복잡한 시스템의 전체 구조를 UML 컴포넌트 다이어그램이나 배포 다이어그램으로 시각화하고, 각 서비스 간의 상호작용을 시퀀스 다이어그램으로 명세한다.
*   **데이터베이스 관리자(DBA) / 데이터 모델러:**
    *   **시나리오:** 데이터베이스 변경 요청 시, 기존 ERD를 불러와 수정하고, 변경된 ERD를 기반으로 SQL DDL 스크립트를 자동 생성하여 데이터베이스에 적용한다.
*   **프로젝트 관리자(PM) / 기획자:**
    *   **시나리오:** 사용자 요구사항을 유스케이스 다이어그램으로 명확히 정의하고, 개발팀과의 커뮤니케이션을 위해 시스템 흐름을 간략한 다이어그램으로 표현한다.
*   **컴퓨터 공학 학생 / 교육자:**
    *   **시나리오:** 데이터베이스 수업에서 ERD를 직접 그려보며 개념을 익히거나, 객체지향 설계 과제에서 UML 다이어그램을 활용하여 설계 능력을 향상시킨다.

#### 1.3. 핵심 특징 및 차별점
*   **크로스 플랫폼 네이티브 경험:**
    *   **웹:** 최신 웹 기술(File System Access API 등)을 활용하여 브라우저 내에서 로컬 파일 시스템과의 긴밀한 연동을 제공한다.
    *   **데스크톱 (Electron):** OS 네이티브 기능(알림, 메뉴 바, 파일 시스템 접근 권한 등)을 활용하여 웹 버전에서는 불가능한 깊이 있는 통합 경험을 제공한다.
    *   **단일 코드베이스:** React.js와 TypeScript 기반의 단일 코드베이스를 통해 웹과 데스크톱 앱을 동시에 개발 및 유지보수하여 개발 효율성을 극대화한다.
*   **직관적인 UI/UX:**
    *   **드래그 앤 드롭:** 툴박스에서 요소를 캔버스로 쉽게 끌어다 놓아 다이어그램을 구성한다.
    *   **인라인 편집:** 다이어그램 요소의 텍스트를 더블 클릭하여 즉시 편집할 수 있도록 지원한다.
    *   **스마트 가이드:** 요소 이동 시 다른 요소와의 정렬을 돕는 시각적 가이드라인을 제공한다.
*   **다양한 다이어그램 유형 지원:**
    *   **ERD:** Crow's Foot 표기법을 기본으로 하며, 다양한 관계 유형(1:1, 1:N, N:M) 및 식별/비식별 관계를 시각적으로 명확하게 표현한다.
    *   **UML:** 클래스, 유스케이스, 시퀀스 다이어그램을 우선적으로 지원하며, 각 다이어그램의 핵심 요소와 관계를 정확하게 모델링할 수 있도록 한다.
*   **강력한 파일 관리 및 연동:**
    *   **프로젝트 기반 저장:** 단일 `.json` 파일에 여러 다이어그램(ERD, UML 등)을 포함하여 저장하는 구조로, 프로젝트 단위의 관리를 용이하게 한다.
    *   **로컬 파일 시스템 연동:** 데스크톱 앱에서는 OS의 파일 탐색기를 통해 직접 파일을 저장하고 불러올 수 있으며, 웹 버전에서는 File System Access API를 통해 유사한 경험을 제공한다.
    *   **자동 저장 및 복구:** 사용자 작업 내용을 주기적으로 임시 저장하여 예기치 않은 종료 시에도 작업 내용을 복구할 수 있도록 한다.
*   **유연한 가져오기/내보내기:**
    *   **이미지 내보내기:** PNG, SVG 형식으로 다이어그램을 고품질로 내보내어 문서화 및 공유를 용이하게 한다.
    *   **SQL DDL 생성 (ERD):** 작성된 ERD를 기반으로 `CREATE TABLE`, `ALTER TABLE` 등의 SQL DDL 스크립트를 자동 생성하여 데이터베이스 구축 시간을 단축한다. (향후 MySQL, PostgreSQL, Oracle 등 다양한 DB Dialect 지원 고려)
    *   **JSON 데이터 내보내기/가져오기:** 프로젝트 전체 데이터를 JSON 형식으로 내보내고 가져올 수 있어, 다른 도구와의 연동 또는 백업/복원에 활용할 수 있다.

---

### 2. 주요 기능 상세

#### 2.1. 공통 에디터 기능

*   **캔버스 관리:**
    *   **무한 캔버스:** 사용자가 제약 없이 다이어그램을 확장할 수 있는 무한 스크롤 캔버스.
    *   **확대/축소 (Zoom In/Out):** 마우스 휠 또는 트랙패드 제스처를 통한 부드러운 확대/축소. 특정 영역 확대/축소 기능도 제공.
    *   **이동 (Pan):** 스페이스바 + 드래그 또는 마우스 우클릭 + 드래그를 통한 캔버스 이동.
    *   **그리드 및 스냅:**
        *   **그리드:** 배경에 격자 무늬를 표시하여 요소 정렬을 돕는다. 그리드 간격 조절 및 표시/숨김 기능.
        *   **스냅:** 요소를 이동하거나 크기를 조절할 때 그리드 선이나 다른 요소에 자동으로 스냅되어 정확한 정렬을 돕는다.
*   **요소(Node) 및 연결선(Edge) 조작:**
    *   **요소 추가:**
        *   좌측 툴박스에서 원하는 요소를 캔버스로 드래그 앤 드롭.
        *   캔버스 특정 위치 더블 클릭 시 기본 요소 자동 생성.
        *   단축키를 통한 요소 추가 (예: `E` 키로 Entity 추가, `C` 키로 Class 추가).
    *   **요소 선택:** 단일 선택 (클릭), 다중 선택 (Shift + 클릭, 드래그 박스 선택).
    *   **요소 이동 및 크기 조절:** 드래그를 통한 이동, 핸들을 통한 크기 조절. 비율 유지 옵션.
    *   **연결선 생성:** 요소의 연결 포트(Anchor Point)를 드래그하여 다른 요소의 연결 포트로 연결. 연결선 유형(직선, 곡선, 직각선) 선택 가능.
    *   **속성 편집 (우측 속성 패널):**
        *   선택된 요소의 모든 속성(텍스트, 색상, 폰트, 크기, 관계 유형 등)을 실시간으로 편집.
        *   입력 유효성 검사 및 피드백 제공.
        *   컨텍스트 메뉴 (우클릭): 선택된 요소에 대한 빠른 작업 메뉴 제공 (복사, 붙여넣기, 삭제, 정렬, 그룹화 등).
*   **실행 취소/다시 실행 (Undo/Redo):** 모든 캔버스 조작 및 속성 변경에 대한 무제한 실행 취소/다시 실행 지원. (Command/Ctrl + Z, Command/Ctrl + Shift + Z)
*   **복사/붙여넣기/잘라내기 (Copy/Paste/Cut):** 선택된 요소를 클립보드에 복사하여 다른 위치나 다른 다이어그램에 붙여넣기. (Command/Ctrl + C, V, X)
*   **그룹화/그룹 해제:** 여러 요소를 하나의 그룹으로 묶어 함께 이동, 복사, 삭제할 수 있도록 지원.
*   **레이어 관리:** 요소들의 Z-index를 조절하여 앞/뒤 순서 변경 (맨 앞으로 가져오기, 맨 뒤로 보내기 등).

#### 2.2. ERD 기능 상세

*   **엔티티 (Entity):**
    *   **속성 (Attribute) 관리:**
        *   속성 추가/삭제/순서 변경.
        *   속성별 이름, 데이터 타입(VARCHAR, INT, DATE 등), 길이, NULL 허용 여부, 기본값 설정.
        *   **키(Key) 지정:** Primary Key (PK), Foreign Key (FK), Unique Key (UK) 명확히 표시.
        *   PK는 밑줄, FK는 기울임꼴 등으로 시각적 구분.
    *   **표기법:** Crow's Foot (까마귀발) 표기법을 기본으로 지원하며, 향후 Chen's Notation, Barker's Notation 등 추가 고려.
*   **관계 (Relationship):**
    *   **카디널리티 (Cardinality):** 1:1, 1:N, N:M 관계를 시각적으로 명확하게 표현 (예: 1, 0..1, 1..*, 0..*).
    *   **식별/비식별 관계:**
        *   **식별 관계 (Identifying Relationship):** 부모 엔티티의 PK가 자식 엔티티의 PK의 일부가 되는 경우. 실선으로 표현.
        *   **비식별 관계 (Non-Identifying Relationship):** 부모 엔티티의 PK가 자식 엔티티의 일반 속성(FK)이 되는 경우. 점선으로 표현.
    *   **관계명:** 관계선에 관계의 의미를 나타내는 텍스트 추가.
*   **SQL DDL (Data Definition Language) 내보내기:**
    *   작성된 ERD를 기반으로 `CREATE TABLE`, `ALTER TABLE` (FK 제약조건) 등의 SQL 스크립트 자동 생성.
    *   **데이터베이스 Dialect 선택:** MySQL, PostgreSQL, SQLite 등 주요 RDBMS에 맞는 DDL 문법 선택 기능 (초기에는 MySQL/PostgreSQL 우선 지원).
    *   생성된 SQL 스크립트 미리보기 및 복사 기능.

#### 2.3. UML 기능 상세

*   **클래스 다이어그램 (Class Diagram):**
    *   **클래스/인터페이스:** 이름, 스테레오타입(<<interface>>), 가시성(public, private, protected, package).
    *   **속성 (Attribute):** 이름, 타입, 가시성, 기본값.
    *   **메서드 (Method):** 이름, 반환 타입, 파라미터, 가시성, 추상/정적 여부.
    *   **관계:**
        *   **상속 (Inheritance/Generalization):** 빈 삼각형 화살표.
        *   **구현 (Realization):** 점선 빈 삼각형 화살표.
        *   **연관 (Association):** 실선. 양방향/단방향, 다중성(Cardinality), 역할명(Role Name) 표현.
        *   **집합 (Aggregation):** 빈 마름모.
        *   **합성 (Composition):** 채워진 마름모.
        *   **의존 (Dependency):** 점선 화살표.
*   **유스케이스 다이어그램 (Use Case Diagram):**
    *   **액터 (Actor):** 사람 또는 외부 시스템.
    *   **유스케이스 (Use Case):** 시스템이 제공하는 기능.
    *   **시스템 경계 (System Boundary):** 시스템의 범위를 나타내는 박스.
    *   **관계:** 연관 (Association), 포함 (Include), 확장 (Extend).
*   **시퀀스 다이어그램 (Sequence Diagram):**
    *   **생명선 (Lifeline):** 객체 또는 액터의 존재 기간.
    *   **활성 상자 (Activation Box):** 객체가 메시지를 처리하는 동안의 활성화 기간.
    *   **메시지 (Message):**
        *   **동기 메시지:** 실선 화살표.
        *   **비동기 메시지:** 점선 화살표.
        *   **반환 메시지:** 점선 화살표.
    *   **프래그먼트 (Fragment):** Alt (대안), Opt (선택), Loop (반복), Par (병렬) 등.

#### 2.4. 파일 및 프로젝트 관리 상세

*   **프로젝트 파일 형식 (`.erduml`):**
    *   모든 다이어그램 데이터, 캔버스 설정, 메타데이터(프로젝트 이름, 생성일, 수정일)를 포함하는 단일 JSON 파일.
    *   파일 확장자는 `.erduml`을 사용하여 본 애플리케이션과의 연관성을 명확히 한다.
    *   내부적으로는 버전 관리를 위한 `version` 필드를 포함하여 향후 스키마 변경에 대비한다.
*   **저장/불러오기 메커니즘:**
    *   **웹 (File System Access API):**
        *   `window.showSaveFilePicker()` 및 `window.showOpenFilePicker()`를 사용하여 사용자에게 파일 저장/열기 대화상자를 제공.
        *   사용자 권한 하에 로컬 파일 시스템에 직접 파일을 읽고 쓸 수 있어 데스크톱 앱과 유사한 경험 제공. (브라우저 지원 여부 확인 및 폴백 처리 필요)
        *   **폴백:** File System Access API를 지원하지 않는 브라우저의 경우, 파일 다운로드/업로드 방식으로 대체.
    *   **데스크톱 (Electron IPC):**
        *   Electron의 `dialog` 모듈을 사용하여 OS 네이티브 파일 저장/열기 대화상자를 띄운다.
        *   Main 프로세스에서 파일 I/O를 처리하고, Renderer 프로세스와 IPC(Inter-Process Communication)를 통해 데이터를 주고받는다.
*   **자동 저장 및 복구:**
    *   **주기적 자동 저장:** 사용자가 작업 중인 다이어그램 데이터를 `localStorage` (웹) 또는 Electron의 `app.getPath('userData')` 경로 (데스크톱)에 주기적으로 임시 저장. (예: 5분 간격)
    *   **복구 기능:** 애플리케이션 재시작 시, 임시 저장된 데이터가 있을 경우 사용자에게 복구 여부를 묻는 대화상자 제공.
*   **내보내기 (Export):**
    *   **이미지 (PNG, SVG):**
        *   **PNG:** 캔버스 내용을 비트맵 이미지로 렌더링. 배경 투명도 옵션 제공.
        *   **SVG:** 캔버스 내용을 벡터 이미지로 렌더링. 확대해도 깨지지 않아 고품질 문서에 적합.
        *   `html-to-image` 또는 `dom-to-image` 라이브러리 활용 고려.
    *   **JSON 데이터:** 현재 프로젝트의 모든 다이어그램 데이터를 포함하는 `.json` 파일로 내보내기.
*   **가져오기 (Import):
    *   기존 `.erduml` 프로젝트 파일 또는 JSON 데이터를 불러와 편집.
    *   향후 다른 ERD/UML 도구에서 내보낸 표준 형식(예: XMI) 가져오기 기능 고려.

---

### 3. 기술 스택 및 아키텍처 상세

#### 3.1. 기술 스택 선정 이유

*   **언어: TypeScript**
    *   **선정 이유:** 대규모 애플리케이션 개발에 필수적인 타입 안정성을 제공하여 런타임 오류를 줄이고 코드의 가독성 및 유지보수성을 향상시킨다. 풍부한 IDE 지원으로 개발 생산성을 높인다.
*   **UI 프레임워크: React.js**
    *   **선정 이유:** 선언적 UI 개발, 컴포넌트 기반 아키텍처, 활발한 커뮤니티 및 방대한 생태계를 통해 빠르고 효율적인 UI 개발이 가능하다. 특히 다이어그램 에디터와 같이 복잡한 UI 상호작용이 많은 애플리케이션에 적합하다.
*   **다이어그램 라이브러리: React Flow**
    *   **선정 이유:** 노드 기반 에디터 구축에 특화된 라이브러리로, 높은 유연성과 확장성을 제공한다. 커스텀 노드 및 엣지 구현이 용이하며, 줌, 팬, 미니맵 등 다이어그램 에디터에 필요한 핵심 기능을 내장하고 있어 개발 시간을 단축할 수 있다. MIT 라이선스로 상업적 사용에 제약이 적다.
*   **데스크톱 플랫폼: Electron**
    *   **선정 이유:** 웹 기술(HTML, CSS, JavaScript)을 사용하여 데스크톱 애플리케이션을 개발할 수 있게 하여, 웹 버전과의 코드 재사용성을 극대화한다. 크로스 플랫폼(Windows, macOS, Linux) 지원으로 개발 및 배포의 효율성을 높인다.
*   **상태 관리: Zustand 또는 Recoil**
    *   **선정 이유:** Redux와 같은 복잡한 상태 관리 라이브러리보다 가볍고 직관적인 API를 제공하여 학습 곡선이 낮고 개발 편의성이 높다. 특히 React의 Context API와 함께 사용하여 전역 상태 관리를 효율적으로 할 수 있다. 다이어그램 데이터와 같은 복잡한 객체 상태 관리에 용이하다.
*   **스타일링:** Styled-components (컴포넌트 기반 스타일링 및 동적 테마 지원)
*   **빌드/번들러: Vite**
    *   **선정 이유:** ES Module 기반의 빠른 개발 서버 시작 및 HMR(Hot Module Replacement)을 제공하여 개발 경험을 크게 향상시킨다. Rollup 기반의 최적화된 프로덕션 빌드를 생성하여 성능이 우수하다.
*   **패키지 매니저: pnpm**
    *   **선정 이유:** 모노레포 환경에서 의존성 설치 속도가 빠르고 디스크 공간을 효율적으로 사용한다(하드 링크를 통한 중복 제거). `workspace` 기능을 통해 모노레포 내 패키지 간의 의존성 관리가 용이하다.

#### 3.2. 프로젝트 구조 (모노레포 아키텍처)

pnpm workspace를 활용한 모노레포 구조는 코드 재사용성, 일관된 개발 환경, 효율적인 의존성 관리를 가능하게 한다.

```
/erd-uml-editor
├── packages/
│   ├── core/             # 플랫폼 독립적인 핵심 로직 및 데이터 모델
│   │   ├── src/
│   │   │   ├── data-models/  # ERD, UML 요소의 TypeScript 인터페이스 및 클래스 정의
│   │   │   ├── services/     # DDL 생성, 데이터 변환 등 비즈니스 로직
│   │   │   └── utils/        # 공통 유틸리티 함수
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   ├── app-web/          # 웹 애플리케이션 (React.js)
│   │   ├── public/
│   │   ├── src/
│   │   │   ├── components/   # 재사용 가능한 UI 컴포넌트
│   │   │   ├── hooks/        # React Custom Hooks
│   │   │   ├── pages/        # 라우팅 페이지
│   │   │   ├── styles/       # Styled-components 설정 및 전역 스타일
│   │   │   ├── App.tsx
│   │   │   └── main.tsx
│   │   ├── index.html
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── vite.config.ts
│   │
│   ├── app-electron/     # Electron 데스크톱 애플리케이션
│   │   ├── main/         # Electron Main Process (Node.js 환경)
│   │   │   ├── index.ts      # 메인 프로세스 엔트리 포인트
│   │   │   └── handlers.ts   # IPC 핸들러 (파일 I/O, OS 다이얼로그 등)
│   │   ├── preload/      # Electron Preload Script (Renderer와 Main 간 안전한 통신)
│   │   │   └── index.ts
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── electron-builder.yml # 빌드 설정
│   │
│   └── ui-components/    # (선택 사항) 공통 UI 컴포넌트 라이브러리 (Storybook 연동 고려)
│       ├── src/
│       ├── package.json
│       └── tsconfig.json
│
├── pnpm-workspace.yaml   # pnpm 워크스페이스 설정
├── package.json          # 루트 패키지 (스크립트, 개발 의존성)
├── tsconfig.json         # 루트 TypeScript 설정
└── README.md
```

*   **`packages/core`:**
    *   **역할:** 다이어그램의 데이터 모델(엔티티, 클래스, 관계 등) 정의, DDL 생성 로직, 다이어그램 데이터 변환 및 유효성 검사 등 플랫폼에 독립적인 핵심 비즈니스 로직을 포함한다.
    *   **의존성:** 다른 `packages`에서 이 패키지를 의존하여 핵심 기능을 재사용한다.
*   **`packages/app-web`:**
    *   **역할:** `core` 패키지의 비즈니스 로직을 활용하여 사용자에게 다이어그램 편집 UI를 제공하는 웹 애플리케이션. React Flow를 사용하여 캔버스 및 요소 렌더링을 담당한다.
    *   **의존성:** `core` 패키지에 의존한다.
*   **`packages/app-electron`:**
    *   **역할:** `app-web`을 웹뷰로 로드하여 데스크톱 애플리케이션으로 패키징한다. Main 프로세스에서는 OS 네이티브 기능(파일 시스템 접근, 메뉴 바 등)을 제어하고, Preload 스크립트를 통해 Renderer 프로세스(웹뷰)와 안전하게 통신한다.
    *   **의존성:** `app-web` 패키지에 의존하여 웹 애플리케이션의 빌드 결과물을 사용한다.
*   **`packages/ui-components` (선택 사항):**
    *   **역할:** 웹과 데스크톱 앱에서 공통으로 사용될 재사용 가능한 UI 컴포넌트(버튼, 입력 필드, 모달 등)를 정의한다. Storybook과 연동하여 컴포넌트 개발 및 문서화를 용이하게 할 수 있다.
    *   **의존성:** `app-web` 및 `app-electron`이 이 패키지에 의존한다.

#### 3.3. 통신 아키텍처 (Electron)

Electron 앱에서는 Main 프로세스와 Renderer 프로세스 간의 안전하고 효율적인 통신이 중요하다.

*   **IPC (Inter-Process Communication):**
    *   **`ipcMain` (Main Process):** Renderer 프로세스에서 보낸 메시지를 수신하고, 필요한 경우 응답을 보낸다. 파일 I/O, OS 다이얼로그 호출 등 Main 프로세스에서만 가능한 작업을 처리한다.
    *   **`ipcRenderer` (Renderer Process):** Main 프로세스로 메시지를 보내고, Main 프로세스에서 보낸 응답을 수신한다.
    *   **`contextBridge` (Preload Script):** Renderer 프로세스에서 직접 Node.js API에 접근하는 것을 방지하고, Main 프로세스와의 통신을 위한 안전한 브릿지를 제공한다. `window.electronAPI`와 같은 전역 객체를 통해 노출된다.

```typescript
// app-electron/main/index.ts (Main Process)
import { ipcMain, dialog } from 'electron';
import fs from 'fs/promises';

ipcMain.handle('save-file', async (event, filePath, content) => {
  try {
    await fs.writeFile(filePath, content, 'utf-8');
    return { success: true };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('open-file-dialog', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [{ name: 'ERD/UML Project', extensions: ['erduml'] }]
  });
  if (canceled) return null;
  return filePaths[0];
});

// app-electron/preload/index.ts (Preload Script)
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  saveFile: (filePath: string, content: string) => ipcRenderer.invoke('save-file', filePath, content),
  openFileDialog: () => ipcRenderer.invoke('open-file-dialog'),
  // ... 기타 IPC 통신 함수
});

// app-web/src/App.tsx (Renderer Process - React Component)
declare global {
  interface Window {
    electronAPI?: {
      saveFile: (filePath: string, content: string) => Promise<{ success: boolean; message?: string }>;
      openFileDialog: () => Promise<string | null>;
    };
  }
}

const handleSave = async (data: string) => {
  if (window.electronAPI) {
    const filePath = await window.electronAPI.openFileDialog();
    if (filePath) {
      const result = await window.electronAPI.saveFile(filePath, data);
      if (result.success) {
        console.log('File saved successfully!');
      } else {
        console.error('Failed to save file:', result.message);
      }
    }
  } else {
    // 웹 버전의 파일 저장 로직 (File System Access API 또는 다운로드)
  }
};
```

---

### 4. 데이터 모델 (JSON 스키마) 상세

프로젝트 파일은 `.erduml` 확장자를 가지는 JSON 형식으로 저장된다. 이 스키마는 다이어그램의 모든 요소와 그 속성을 포함하며, React Flow의 내부 데이터 구조와 호환되도록 설계된다.

```json
{
  "projectName": "My Software Project",
  "version": "1.0.0",
  "createdAt": "2025-07-19T10:00:00Z",
  "lastModifiedAt": "2025-07-19T11:30:00Z",
  "diagrams": [
    {
      "id": "diag-erd-users",
      "name": "User Management ERD",
      "type": "ERD",
      "nodes": [
        {
          "id": "entity-user",
          "type": "erd-entity",
          "position": { "x": 100, "y": 150 },
          "data": {
            "name": "User",
            "attributes": [
              { "id": "attr-user-id", "name": "user_id", "dataType": "INT", "isPK": true, "isFK": false, "isNullable": false, "defaultValue": null, "comment": "Primary key for User" },
              { "id": "attr-user-name", "name": "username", "dataType": "VARCHAR(50)", "isPK": false, "isFK": false, "isNullable": false, "defaultValue": null, "comment": "Unique username" },
              { "id": "attr-user-email", "name": "email", "dataType": "VARCHAR(100)", "isPK": false, "isFK": false, "isNullable": false, "defaultValue": null, "comment": "User email address" },
              { "id": "attr-user-created", "name": "created_at", "dataType": "DATETIME", "isPK": false, "isFK": false, "isNullable": false, "defaultValue": "CURRENT_TIMESTAMP", "comment": "Record creation timestamp" }
            ]
          },
          "width": 200,
          "height": 180
        },
        {
          "id": "entity-post",
          "type": "erd-entity",
          "position": { "x": 400, "y": 150 },
          "data": {
            "name": "Post",
            "attributes": [
              { "id": "attr-post-id", "name": "post_id", "dataType": "INT", "isPK": true, "isFK": false, "isNullable": false, "defaultValue": null, "comment": "Primary key for Post" },
              { "id": "attr-post-title", "name": "title", "dataType": "VARCHAR(255)", "isPK": false, "isFK": false, "isNullable": false, "defaultValue": null, "comment": "Post title" },
              { "id": "attr-post-content", "name": "content", "dataType": "TEXT", "isPK": false, "isFK": false, "isNullable": true, "defaultValue": null, "comment": "Post content" },
              { "id": "attr-post-user-id", "name": "user_id", "dataType": "INT", "isPK": false, "isFK": true, "isNullable": false, "defaultValue": null, "comment": "Foreign key to User" }
            ]
          },
          "width": 200,
          "height": 200
        }
      ],
      "edges": [
        {
          "id": "edge-user-post",
          "source": "entity-user",
          "target": "entity-post",
          "type": "erd-relationship",
          "sourceHandle": "bottom",
          "targetHandle": "left",
          "data": {
            "sourceCardinality": "1",
            "targetCardinality": "N",
            "relationshipType": "non-identifying",
            "name": "writes"
          }
        }
      ],
      "viewport": { "x": 0, "y": 0, "zoom": 1 }
    },
    {
      "id": "diag-uml-auth",
      "name": "Authentication Class Diagram",
      "type": "UML_CLASS",
      "nodes": [
        {
          "id": "class-user",
          "type": "uml-class",
          "position": { "x": 100, "y": 100 },
          "data": {
            "name": "User",
            "attributes": [
              { "name": "username", "type": "string", "visibility": "private" },
              { "name": "passwordHash", "type": "string", "visibility": "private" }
            ],
            "methods": [
              { "name": "login", "returnType": "boolean", "parameters": [{ "name": "username", "type": "string" }, { "name": "password", "type": "string" }], "visibility": "public" },
              { "name": "register", "returnType": "boolean", "parameters": [{ "name": "username", "type": "string" }, { "name": "password", "type": "string" }], "visibility": "public" }
            ]
          }
        }
      ],
      "edges": [],
      "viewport": { "x": 0, "y": 0, "zoom": 1 }
    }
  ]
}
```

**스키마 설명:**

*   **`projectName` (string):** 프로젝트의 이름.
*   **`version` (string):** 프로젝트 파일 스키마의 버전. 향후 하위 호환성 유지를 위해 사용.
*   **`createdAt` (string):** 프로젝트 생성 일시 (ISO 8601 형식).
*   **`lastModifiedAt` (string):** 프로젝트 최종 수정 일시 (ISO 8601 형식).
*   **`diagrams` (Array<Object>):** 프로젝트 내에 포함된 다이어그램들의 배열.
    *   **`id` (string):** 다이어그램의 고유 ID.
    *   **`name` (string):** 다이어그램의 이름.
    *   **`type` (string):** 다이어그램의 유형 (예: "ERD", "UML_CLASS", "UML_USECASE", "UML_SEQUENCE").
    *   **`nodes` (Array<Object>):** 다이어그램 내의 모든 노드(요소) 배열. React Flow의 Node 객체 구조를 따른다.
        *   **`id` (string):** 노드의 고유 ID.
        *   **`type` (string):** 노드의 커스텀 타입 (예: "erd-entity", "uml-class"). 이를 통해 React Flow에서 해당 타입에 맞는 커스텀 컴포넌트를 렌더링한다.
        *   **`position` (Object):** 캔버스 내 노드의 `x`, `y` 좌표.
        *   **`data` (Object):** 노드에 특화된 데이터.
            *   **`erd-entity` 타입의 `data`:**
                *   `name` (string): 엔티티 이름.
                *   `attributes` (Array<Object>): 속성 배열.
                    *   `id` (string): 속성 고유 ID.
                    *   `name` (string): 속성 이름.
                    *   `dataType` (string): 데이터 타입 (예: "INT", "VARCHAR(255)").
                    *   `isPK` (boolean): Primary Key 여부.
                    *   `isFK` (boolean): Foreign Key 여부.
                    *   `isNullable` (boolean): NULL 허용 여부.
                    *   `defaultValue` (string | null): 기본값.
                    *   `comment` (string | null): 속성 설명.
            *   **`uml-class` 타입의 `data`:**
                *   `name` (string): 클래스 이름.
                *   `attributes` (Array<Object>): 속성 배열.
                    *   `name` (string): 속성 이름.
                    *   `type` (string): 속성 타입.
                    *   `visibility` (string): 가시성 ("public", "private", "protected", "package").
                *   `methods` (Array<Object>): 메서드 배열.
                    *   `name` (string): 메서드 이름.
                    *   `returnType` (string): 반환 타입.
                    *   `parameters` (Array<Object>): 파라미터 배열.
                        *   `name` (string): 파라미터 이름.
                        *   `type` (string): 파라미터 타입.
                    *   `visibility` (string): 가시성.
        *   **`width` (number), `height` (number):** 노드의 크기 (선택 사항, React Flow에서 자동 계산될 수 있음).
    *   **`edges` (Array<Object>):** 다이어그램 내의 모든 연결선 배열. React Flow의 Edge 객체 구조를 따른다.
        *   **`id` (string):** 엣지의 고유 ID.
        *   **`source` (string):** 시작 노드의 ID.
        *   **`target` (string):** 끝 노드의 ID.
        *   **`type` (string):** 엣지의 커스텀 타입 (예: "erd-relationship", "uml-association").
        *   **`sourceHandle` (string), `targetHandle` (string):** 연결 포트의 ID (React Flow에서 사용).
        *   **`data` (Object):** 엣지에 특화된 데이터.
            *   **`erd-relationship` 타입의 `data`:**
                *   `sourceCardinality` (string): 시작 엔티티의 카디널리티 (예: "1", "N").
                *   `targetCardinality` (string): 대상 엔티티의 카디널리티 (예: "1", "N", "M").
                *   `relationshipType` (string): 관계 유형 ("identifying", "non-identifying").
                *   `name` (string | null): 관계 이름.
            *   **`uml-association` 타입의 `data`:**
                *   `associationType` (string): 연관 유형 ("association", "aggregation", "composition", "inheritance", "realization", "dependency").
                *   `sourceMultiplicity` (string | null): 시작점 다중성.
                *   `targetMultiplicity` (string | null): 끝점 다중성.
                *   `name` (string | null): 연관 이름.
    *   **`viewport` (Object):** 캔버스의 현재 뷰포트 상태 (`x`, `y` 이동, `zoom` 레벨).

---

### 5. UI/UX 설계 상세

#### 5.1. 레이아웃 및 인터랙션 플로우

*   **상단 헤더 (Top Header):**
    *   **메뉴 바:** "파일(File)", "편집(Edit)", "보기(View)", "도움말(Help)" 등 표준 애플리케이션 메뉴.
        *   **파일:** 새 프로젝트, 열기, 저장, 다른 이름으로 저장, 내보내기(이미지, SQL, JSON), 종료.
        *   **편집:** 실행 취소/다시 실행, 잘라내기, 복사, 붙여넣기, 삭제, 모두 선택.
        *   **보기:** 확대/축소, 그리드 표시/숨김, 미니맵 표시/숨김, 다크/라이트 모드 전환.
    *   **프로젝트 이름:** 현재 열려있는 프로젝트의 이름 표시.
    *   **주요 도구 아이콘:** 저장, 내보내기, 새 다이어그램 추가 등 자주 사용하는 기능에 대한 빠른 접근 아이콘.
    *   **다이어그램 탭:** 여러 다이어그램이 열려 있을 경우 탭 형태로 표시하여 쉽게 전환 가능.
*   **왼쪽 패널 (툴박스 - Left Sidebar / Toolbox):**
    *   **다이어그램 유형 선택:** ERD, UML 클래스, UML 유스케이스 등 현재 편집할 다이어그램 유형을 선택하는 드롭다운 또는 탭.
    *   **요소 팔레트:** 선택된 다이어그램 유형에 맞는 요소(노드) 목록.
        *   **ERD:** 엔티티, 주석 등.
        *   **UML 클래스:** 클래스, 인터페이스, 주석 등.
        *   각 요소를 캔버스로 드래그 앤 드롭하여 추가.
        *   요소 아이콘과 함께 간략한 설명 툴팁 제공.
*   **중앙 캔버스 (Main Canvas):**
    *   **주 작업 공간:** 다이어그램 요소들이 배치되고 편집되는 핵심 영역.
    *   **그리드:** 배경에 그리드 표시 (설정에서 켜고 끌 수 있음).
    *   **미니맵:** 캔버스 우측 하단에 전체 다이어그램의 축소판을 표시하여 넓은 캔버스에서 현재 위치를 파악하고 빠르게 이동할 수 있도록 돕는다.
    *   **컨텍스트 메뉴:** 캔버스 빈 공간 우클릭 시 캔버스 관련 작업(새 요소 추가, 붙여넣기, 전체 확대/축소 등) 메뉴 제공.
*   **오른쪽 패널 (속성 관리자 - Right Sidebar / Property Inspector):**
    *   **선택된 요소의 속성 표시:** 캔버스에서 노드나 엣지가 선택되면 해당 요소의 모든 편집 가능한 속성(이름, 색상, 폰트, 데이터 타입, 관계 유형, 카디널리티 등)을 동적으로 표시.
    *   **속성 편집 UI:** 텍스트 입력 필드, 드롭다운, 체크박스, 색상 피커 등 적절한 UI 컨트롤 제공.
    *   **실시간 업데이트:** 속성 변경 시 캔버스에 즉시 반영.
    *   **유효성 검사:** 입력 값에 대한 유효성 검사 및 오류 메시지 표시.

#### 5.2. 핵심 인터랙션 상세

*   **요소 추가:**
    1.  왼쪽 툴박스에서 '엔티티' 아이콘을 클릭하거나 캔버스로 드래그 앤 드롭.
    2.  캔버스에 새로운 엔티티 노드가 생성된다.
    3.  엔티티 노드를 더블 클릭하여 이름을 즉시 편집하거나, 오른쪽 속성 패널에서 이름을 변경한다.
*   **속성 추가 (ERD 엔티티):**
    1.  엔티티 노드를 선택한다.
    2.  오른쪽 속성 패널에서 '속성 추가' 버튼을 클릭한다.
    3.  새로운 속성 필드가 나타나면 이름, 데이터 타입, PK/FK 여부 등을 입력한다.
*   **관계선 연결:**
    1.  첫 번째 엔티티 노드의 연결 포트(예: 우측 중앙)를 클릭하고 드래그한다.
    2.  드래그하는 동안 관계선 미리보기가 표시된다.
    3.  두 번째 엔티티 노드의 연결 포트에 드롭하면 관계선이 생성된다.
    4.  생성된 관계선을 선택하여 오른쪽 속성 패널에서 카디널리티, 관계 유형(식별/비식별), 관계명 등을 설정한다.
*   **실행 취소/다시 실행:**
    1.  사용자가 어떤 작업을 수행한다 (예: 노드 이동).
    2.  `Ctrl+Z` (Windows) 또는 `Cmd+Z` (macOS)를 누르면 이전 상태로 돌아간다.
    3.  `Ctrl+Shift+Z` 또는 `Cmd+Shift+Z`를 누르면 다시 실행된다.

#### 5.3. 접근성 (Accessibility) 고려 사항

*   **키보드 내비게이션:** 모든 UI 요소와 캔버스 상의 요소들이 키보드만으로 조작 가능하도록 설계 (Tab, Arrow keys, Enter, Spacebar 등).
*   **스크린 리더 지원:** ARIA(Accessible Rich Internet Applications) 속성을 사용하여 스크린 리더 사용자가 UI 요소와 콘텐츠를 이해하고 상호작용할 수 있도록 한다.
*   **색상 대비:** WCAG(Web Content Accessibility Guidelines) 2.1 AA 등급 이상의 색상 대비를 준수하여 시각 장애가 있는 사용자도 콘텐츠를 명확하게 볼 수 있도록 한다.
*   **확대/축소:** 브라우저의 기본 확대/축소 기능과 애플리케이션 내의 캔버스 확대/축소 기능이 모두 원활하게 작동하도록 한다.

#### 5.4. 테마 및 디자인 시스템

*   **다크/라이트 모드:** 사용자의 시스템 설정 또는 애플리케이션 내 토글을 통해 다크 모드와 라이트 모드를 전환할 수 있도록 지원하여 눈의 피로도를 줄이고 개인 선호도를 존중한다.
*   **일관된 디자인 시스템:**
    *   **컴포넌트 라이브러리:** 재사용 가능한 UI 컴포넌트(버튼, 입력 필드, 모달, 아이콘 등)를 정의하고 일관된 스타일을 적용한다.
    *   **타이포그래피:** 가독성을 고려한 폰트 패밀리, 크기, 줄 간격 등을 정의한다.
    *   **색상 팔레트:** 브랜드 아이덴티티를 반영하고 접근성을 고려한 색상 팔레트를 정의한다.
    *   **아이콘:** 직관적이고 통일된 아이콘 세트를 사용한다.

---

### 6. 빌드 및 배포 상세

#### 6.1. 웹 애플리케이션 빌드 및 배포

*   **빌드 스크립트:**
    ```bash
    # app-web 디렉토리에서 실행
    pnpm install # 의존성 설치
    pnpm build   # Vite를 사용하여 프로덕션 빌드
    ```
    *   `pnpm build` 명령은 `app-web/dist` 디렉토리에 정적 HTML, CSS, JavaScript 파일들을 생성한다.
*   **배포 환경:**
    *   **정적 호스팅 서비스:** Netlify, Vercel, GitHub Pages, AWS S3 + CloudFront 등.
    *   **CI/CD 파이프라인:** GitHub Actions, GitLab CI/CD 등을 사용하여 `main` 브랜치에 푸시될 때마다 자동으로 빌드 및 배포를 트리거하도록 설정.
    *   **도메인:** 사용자 친화적인 도메인 설정 (예: `app.erduml.com`).

#### 6.2. 데스크톱 애플리케이션 빌드 및 배포

*   **빌드 도구:** `electron-builder` 또는 `electron-forge` 사용. `electron-builder`는 다양한 플랫폼(Windows, macOS, Linux)에 대한 빌드 및 패키징 기능을 강력하게 지원한다.
*   **빌드 스크립트 (루트 `package.json`):**
    ```json
    {
      "scripts": {
        "build:web": "pnpm --filter app-web build",
        "build:electron": "pnpm build:web && electron-builder --dir",
        "dist:electron": "pnpm build:web && electron-builder --publish never"
      },
      "devDependencies": {
        "electron": "^28.0.0",
        "electron-builder": "^24.0.0"
      }
    }
    ```
    *   `build:web`: Electron 앱을 빌드하기 전에 웹 애플리케이션을 먼저 빌드하여 최신 웹 콘텐츠를 포함하도록 한다.
    *   `build:electron`: 개발용 빌드 (압축되지 않은 디렉토리).
    *   `dist:electron`: 배포용 설치 파일 생성 (exe, dmg, AppImage 등). `--publish never`는 빌드 후 자동 배포를 비활성화한다.
*   **Electron Builder 설정 (`app-electron/electron-builder.yml`):**
    ```yaml
    appId: com.yourcompany.erduml
    productName: ERD-UML Editor
    directories:
      output: ../../dist/electron # 빌드 결과물 저장 경로
      buildResources: resources   # 아이콘 등 리소스 경로
    files:
      - package.json
      - main/**/*
      - preload/**/*
      - ../../packages/app-web/dist/**/* # 웹 빌드 결과물 포함
    win:
      target:
        - target: nsis
          arch:
            - x64
      icon: resources/icon.ico
    mac:
      target:
        - target: dmg
          arch:
            - x64
            - arm64
      icon: resources/icon.icns
    linux:
      target:
        - AppImage
        - deb
      icon: resources/icon.png
    ```
*   **배포 채널:**
    *   **웹사이트 다운로드:** 공식 웹사이트를 통해 각 OS별 설치 파일 제공.
    *   **GitHub Releases:** GitHub 레포지토리의 Releases 기능을 활용하여 버전별 설치 파일 및 변경 로그 관리.
    *   **자동 업데이트:** `electron-updater` 라이브러리를 사용하여 앱 내에서 자동 업데이트 기능을 구현하여 사용자 편의성을 높인다. (초기 MVP에서는 제외될 수 있음)
    *   **앱 스토어:** Windows Store, Mac App Store 등 각 OS의 공식 앱 스토어 등록 고려 (추가적인 요구사항 및 심사 필요).

---

### 7. 개발 로드맵 (마일스톤) 상세

#### Phase 1: MVP (Minimum Viable Product) - 2개월 예상

*   **목표:** 핵심 ERD 기능과 기본적인 파일 관리 기능을 갖춘 웹 및 데스크톱 앱의 동작 가능한 버전을 출시하여 초기 사용자 피드백을 수집한다.
*   **주요 작업:**
    *   **프로젝트 초기 설정 (1주):**
        *   pnpm 모노레포 구조 설정 (`core`, `app-web`, `app-electron` 패키지).
        *   TypeScript, React, Vite, Electron 기본 환경 구성.
        *   Styled-components 설정 및 기본 레이아웃(헤더, 사이드바, 캔버스) 구현.
    *   **기본 캔버스 및 요소 조작 (2주):**
        *   React Flow 통합 및 기본 캔버스(줌, 팬) 구현.
        *   커스텀 노드 렌더링을 위한 `erd-entity` 노드 타입 정의.
        *   노드 이동, 크기 조절, 선택, 삭제 기능 구현.
        *   실행 취소/다시 실행 (Undo/Redo) 기능 구현.
    *   **ERD 핵심 기능 (3주):**
        *   엔티티 노드에 속성 추가/삭제/편집 기능 구현 (이름, 데이터 타입, PK/FK).
        *   `erd-relationship` 엣지 타입 정의 및 엔티티 간 관계선 연결 기능.
        *   카디널리티(1:1, 1:N, N:M) 및 식별/비식별 관계 시각화.
        *   우측 속성 패널에서 엔티티 및 관계 속성 편집 UI 구현.
    *   **파일 관리 (2주):**
        *   프로젝트 데이터 모델(JSON 스키마) 정의 및 `core` 패키지에 구현.
        *   웹 버전: File System Access API를 이용한 `.erduml` 파일 저장/불러오기. (폴백: 다운로드/업로드)
        *   데스크톱 버전: Electron IPC를 이용한 OS 네이티브 파일 저장/불러오기.
        *   PNG 이미지 내보내기 기능 구현.
*   **산출물:**
    *   웹에서 동작하는 ERD 에디터 (엔티티, 속성, 관계선, 저장/불러오기, PNG 내보내기).
    *   Electron 기반의 데스크톱 ERD 에디터 (동일 기능).
    *   기본적인 사용자 가이드 문서.

#### Phase 2: 기능 확장 및 개선 - 3개월 예상

*   **목표:** UML 클래스 다이어그램 기능을 추가하고, 기존 ERD 기능 및 UI/UX를 개선하여 사용성을 높인다.
*   **주요 작업:**
    *   **UML 클래스 다이어그램 기능 (4주):**
        *   `uml-class` 노드 타입 정의 (이름, 속성, 메서드).
        *   속성(이름, 타입, 가시성) 및 메서드(이름, 반환 타입, 파라미터, 가시성) 추가/삭제/편집.
        *   UML 클래스 관계선(상속, 구현, 연관, 집합, 합성, 의존) 타입 정의 및 연결 기능.
        *   우측 속성 패널에서 클래스 및 관계 속성 편집 UI 구현.
    *   **UI/UX 개선 (4주):**
        *   다크/라이트 모드 전환 기능 구현.
        *   그리드 표시/숨김, 스냅 투 그리드 기능 구현.
        *   미니맵 컴포넌트 추가.
        *   주요 기능에 대한 단축키 지원 (저장, 열기, 복사, 붙여넣기 등).
        *   인라인 텍스트 편집 기능 고도화.
    *   **ERD 기능 고도화 (2주):**
        *   ERD DDL SQL 생성 기능 (MySQL/PostgreSQL 기본 지원).
        *   SVG 이미지 내보내기 기능 추가.
    *   **파일 관리 개선 (2주):**
        *   자동 저장 및 복구 기능 구현.
        *   JSON 데이터 내보내기/가져오기 기능.
*   **산출물:**
    *   ERD 및 UML 클래스 다이어그램 편집이 가능한 웹/데스크톱 앱.
    *   SQL DDL 생성 및 SVG 내보내기 기능.
    *   향상된 UI/UX (다크 모드, 그리드, 미니맵, 단축키).

#### Phase 3: 고급 기능 및 안정화 - 3개월 예상

*   **목표:** 추가적인 UML 다이어그램 유형을 지원하고, 성능 최적화 및 안정화 작업을 통해 프로덕션 수준의 품질을 확보한다.
*   **주요 작업:**
    *   **UML 유스케이스 다이어그램 기능 (3주):**
        *   액터, 유스케이스, 시스템 경계 노드 타입 정의.
        *   연관, 포함, 확장 관계선 구현.
    *   **UML 시퀀스 다이어그램 기능 (4주):**
        *   생명선, 활성 상자, 메시지(동기, 비동기, 반환) 구현.
        *   프래그먼트(Alt, Opt, Loop, Par) 구현.
    *   **성능 최적화 (4주):**
        *   대규모 다이어그램(수백 개 노드)에서의 렌더링 성능 최적화.
        *   메모리 사용량 최적화.
        *   번들 사이즈 최적화.
    *   **버그 수정 및 안정화 (2주):**
        *   QA 및 사용자 피드백 기반의 버그 수정.
        *   다양한 OS 및 브라우저 환경에서의 호환성 테스트.
    *   **문서화 및 배포 준비 (1주):**
        *   상세 사용자 매뉴얼 작성.
        *   공식 웹사이트 구축 및 앱 스토어 등록 준비.
*   **산출물:**
    *   ERD, UML 클래스, 유스케이스, 시퀀스 다이어그램 편집이 가능한 완성도 높은 웹/데스크톱 앱.
    *   최적화된 성능과 높은 안정성.
    *   배포 준비 완료.

#### Phase 4: 지속적인 개선 및 확장 - 지속

*   **목표:** 사용자 요구사항을 반영하여 기능을 지속적으로 개선하고, 새로운 다이어그램 유형 및 외부 시스템 연동을 통해 도구의 가치를 확장한다.
*   **주요 작업:**
    *   **새로운 다이어그램 유형 추가:** BPMN, Flowchart, State Machine Diagram 등.
    *   **외부 시스템 연동:** Git 통합(버전 관리), Jira/Confluence 연동, CI/CD 파이프라인 연동.
    *   **협업 기능:** 실시간 다이어그램 공유 및 공동 편집 기능.
    *   **플러그인 아키텍처:** 사용자가 직접 커스텀 요소나 기능을 추가할 수 있는 플러그인 시스템.
    *   **데이터베이스 리버스 엔지니어링:** 기존 데이터베이스 스키마를 읽어 ERD로 자동 생성.
*   **산출물:**
    *   지속적인 업데이트 및 기능 확장.
    *   활발한 커뮤니티 및 사용자 지원.